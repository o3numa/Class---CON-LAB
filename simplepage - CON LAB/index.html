<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>A GIFT 4 SARA</title>
    <link href="style.css" rel="stylesheet"/>
    <!-- Three.js CDN -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  </head>
  <body>
    <!-- Background canvas sits behind everything -->
    <div id="cosmic-bg"></div>

    <main class="content">
      <h1>A GIFT 4 SARA</h1>
      <h2>++++++ All contents by Tomatse Ogedegbe ++++++</h2>

      <p>
        For my exploratory making class in week 3, I tried to make Sara a pair of pants as a gift.
        I used some yards of leather & wool I got from Materials For the Arts in Long Island City, NY
        (via Alexandros Barbayianis). I didn't end up sucessfully completing the pants within a week
        because I caught an allergic reaction on my thumb from the wool (that I'd forgotten I'm allergic to)
        and had to stop halfway through stitching the fly. I tried and documented my stuff though so...
        everything you see on the page is part of my processes... I'll probably pick up from where I left off
        here one day soon enough. - o3NUMA
      </p>

      <a href="https://www.oritse.ooo">plz clik</a>
      <img alt="an oritse flag by numa.o3" src="./mf.gif"/>

      <h3>Process Videos</h3>
      <div class="video-row">
        <video controls>
          <source src="doc-EM.mp4" type="video/mp4">
        </video>
        <video controls>
          <source src="Cargo-Pants-Dimensions-EM.mp4" type="video/mp4">
        </video>
      </div>
    </main>

    <script>
      // ========= THREE.JS COSMIC NAIJA SOLAR SYSTEM =========
      const container = document.getElementById('cosmic-bg');

      // Scene, camera, renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);
      camera.position.set(0, 50, 320);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      container.appendChild(renderer.domElement);

      // Starfield (subtle, far)
      function makeStars(count = 4000, radius = 1800) {
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
          // random in sphere
          const r = radius * Math.cbrt(Math.random());
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(THREE.MathUtils.randFloatSpread(2)); // [0,π]
          const x = r * Math.sin(phi) * Math.cos(theta);
          const y = r * Math.sin(phi) * Math.sin(theta);
          const z = r * Math.cos(phi);
          pos.set([x, y, z], i * 3);
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({
          size: 1.2,
          color: 0xffffff,
          opacity: 0.9,
          transparent: true,
          depthWrite: false
        });
        const stars = new THREE.Points(geo, mat);
        stars.name = "stars";
        scene.add(stars);
        return stars;
      }
      const stars = makeStars();

      // Sun (cloud-point green glow)
      const sunGroup = new THREE.Group();
      scene.add(sunGroup);

      const sunGeom = new THREE.SphereGeometry(50, 64, 64);
      const sunMat = new THREE.MeshStandardMaterial({
        color: 0x00c86e,          // Naija green
        emissive: 0x00c86e,
        emissiveIntensity: 1.6,
        roughness: 0.35,
        metalness: 0.2
      });
      const sunMesh = new THREE.Mesh(sunGeom, sunMat);
      sunGroup.add(sunMesh);

      // Sunlight
      const sunLight = new THREE.PointLight(0x00d27a, 6, 3000, 2);
      sunLight.position.set(0, 0, 0);
      sunGroup.add(sunLight);

      // Soft halo glow sprite around the sun (procedural radial gradient)
      function radialSprite(size = 600, inner = 'rgba(0,210,122,0.8)', outer = 'rgba(0,210,122,0.0)') {
        const cvs = document.createElement('canvas');
        const s = 512;
        cvs.width = cvs.height = s;
        const ctx = cvs.getContext('2d');
        const g = ctx.createRadialGradient(s/2, s/2, s*0.05, s/2, s/2, s*0.5);
        g.addColorStop(0, inner);
        g.addColorStop(1, outer);
        ctx.fillStyle = g;
        ctx.fillRect(0,0,s,s);
        const tex = new THREE.CanvasTexture(cvs);
        tex.colorSpace = THREE.SRGBColorSpace;
        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
        const spr = new THREE.Sprite(mat);
        spr.scale.set(size, size, 1);
        return spr;
      }
      const sunGlow = radialSprite(650);
      sunGroup.add(sunGlow);

      // "Divine rays" — large faint conical sprite
      function raysSprite(size = 1600) {
        const cvs = document.createElement('canvas');
        const s = 1024;
        cvs.width = cvs.height = s;
        const ctx = cvs.getContext('2d');

        // paint dark transparent base
        ctx.clearRect(0,0,s,s);
        // radial fade
        const rad = ctx.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2);
        rad.addColorStop(0.0, 'rgba(0,0,0,0)');
        rad.addColorStop(1.0, 'rgba(0,0,0,0.9)');
        ctx.fillStyle = rad;
        ctx.fillRect(0,0,s,s);

        // carve rays by lighter strokes
        ctx.globalCompositeOperation = 'lighter';
        for (let i = 0; i < 32; i++) {
          const angle = (i / 32) * Math.PI * 2;
          ctx.save();
          ctx.translate(s/2, s/2);
          ctx.rotate(angle);
          const grad = ctx.createLinearGradient(0,0, s/2,0);
          grad.addColorStop(0, 'rgba(0,210,122,0.35)');
          grad.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = grad;
          ctx.globalAlpha = (i % 2 === 0) ? 0.4 : 0.18;
          ctx.fillRect(0, -3, s/2, 6);
          ctx.restore();
        }

        const tex = new THREE.CanvasTexture(cvs);
        tex.colorSpace = THREE.SRGBColorSpace;
        const mat = new THREE.SpriteMaterial({
          map: tex,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        const spr = new THREE.Sprite(mat);
        spr.scale.set(size, size, 1);
        return spr;
      }
      const rays = raysSprite();
      sunGroup.add(rays);

      // Orbiting globes (greens/whites) with slight texture via noise in vertex normals
      function makePlanet({ radius, distance, speed, color, emissive = 0x000000, roughness = 0.5, metalness = 0.2 }) {
        const pivot = new THREE.Object3D();
        scene.add(pivot);

        const geo = new THREE.SphereGeometry(radius, 48, 48);
        const mat = new THREE.MeshStandardMaterial({ color, emissive, roughness, metalness });

        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.x = distance;

        // subtle banding/texture via vertex colors (fake)
        const arr = geo.attributes.position.array;
        const n = geo.attributes.normal;
        const c = new THREE.Color();
        const colors = new Float32Array(geo.attributes.position.count * 3);
        for (let i = 0; i < geo.attributes.position.count; i++) {
          const ny = n.getY(i);
          // create green/white bands by latitude
          if (Math.sin((ny + 1) * Math.PI * 3) > 0.5) {
            c.set(0xffffff);
          } else {
            c.set(color);
          }
          colors[i*3] = c.r;
          colors[i*3+1] = c.g;
          colors[i*3+2] = c.b;
        }
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        mat.vertexColors = true;

        pivot.add(mesh);
        return { pivot, mesh, speed };
      }

      const planets = [
        makePlanet({ radius: 12, distance: 110, speed: 0.006, color: 0x00a86b, emissive: 0x003d24, roughness: 0.6 }),
        makePlanet({ radius: 18, distance: 170, speed: 0.004, color: 0xffffff, emissive: 0x0a1f14, roughness: 0.35, metalness: 0.35 }),
        makePlanet({ radius: 10, distance: 230, speed: 0.008, color: 0x008f57, emissive: 0x002b1a, roughness: 0.5 })
      ];

      // Ambient fill so the darker sides aren’t pitch black
      scene.add(new THREE.AmbientLight(0x0c2018, 0.8));

      // Animation
      const clock = new THREE.Clock();
      function animate() {
        const t = clock.getElapsedTime();

        // gentle rotation of sun/rays for life
        sunMesh.rotation.y = t * 0.1;
        rays.rotation.z = t * 0.05;

        // rotate starfield very slowly
        stars.rotation.y = t * 0.01;

        // orbit planets
        planets.forEach(p => {
          p.pivot.rotation.y += p.speed;
          p.mesh.rotation.y += 0.01;
        });

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();

      // Resize
      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
